{
  "version": 3,
  "sources": ["../../src/utils/url.ts"],
  "sourcesContent": ["import path from 'node:path';\nimport { URL } from 'node:url';\nimport type { ConnectionOptions } from 'pg-connection-string';\nimport pgConnectionString from 'pg-connection-string';\nimport type { Dialect, DialectOptions, Options } from '../sequelize';\nimport { SUPPORTED_DIALECTS } from '../sequelize-typescript';\nimport { encodeHost } from './deprecations';\n\n/**\n * Parses a connection string into an Options object with connection properties\n *\n * @param connectionString string value in format schema://username:password@host:port/database\n */\nexport function parseConnectionString(connectionString: string): Options {\n  const options: Options = {};\n\n  // The following connectionStrings are not valid URLs, but they are supported by sqlite.\n  if (connectionString === 'sqlite://:memory:' || connectionString === 'sqlite::memory:') {\n    options.dialect = 'sqlite';\n    options.storage = ':memory:';\n\n    return options;\n  }\n\n  const urlObject = new URL(connectionString);\n\n  if (urlObject.protocol) {\n    let protocol = urlObject.protocol.replace(/:$/, '');\n    if (protocol === 'postgresql') {\n      protocol = 'postgres';\n    }\n\n    if (!SUPPORTED_DIALECTS.includes(protocol as Dialect)) {\n      throw new Error(`The protocol was set to ${JSON.stringify(protocol)}, which is not a supported dialect. Set it to one of ${SUPPORTED_DIALECTS.map(d => JSON.stringify(d)).join(', ')} instead.`);\n    }\n\n    options.dialect = protocol as Dialect;\n  }\n\n  if (urlObject.hostname != null) {\n    // TODO: rename options.host to options.hostname, as host can accept a port while hostname can't\n    options.host = decodeURIComponent(urlObject.hostname);\n  }\n\n  if (urlObject.pathname) {\n    // decode the URI component from urlObject.pathname value\n    options.database = decodeURIComponent(urlObject.pathname.replace(/^\\//, ''));\n  }\n\n  if (urlObject.port) {\n    options.port = urlObject.port;\n  }\n\n  if (urlObject.username) {\n    options.username = decodeURIComponent(urlObject.username);\n  }\n\n  if (urlObject.password) {\n    options.password = decodeURIComponent(urlObject.password);\n  }\n\n  if (urlObject.searchParams) {\n    // Allow host query argument to override the url host.\n    // Enables specifying domain socket hosts which cannot be specified via the typical\n    // host part of a url.\n    // TODO: remove this workaround in Sequelize 8\n    if (urlObject.searchParams.has('host')) {\n      encodeHost();\n      options.host = decodeURIComponent(urlObject.searchParams.get('host')!);\n    }\n\n    if (options.dialect === 'sqlite' && urlObject.pathname) {\n      const storagePath = path.join(options.host!, urlObject.pathname);\n      delete options.host;\n      options.storage = path.resolve(options.storage || storagePath);\n    }\n\n    options.dialectOptions = Object.fromEntries(urlObject.searchParams.entries());\n    if (urlObject.searchParams.has('options')) {\n      try {\n        const o = JSON.parse(urlObject.searchParams.get('options')!);\n        options.dialectOptions.options = o;\n      } catch {\n        // Nothing to do, string is not a valid JSON\n        // and thus does not need any further processing\n      }\n    }\n  }\n\n  // For postgres, we can use this helper to load certs directly from the\n  // connection string.\n  if (options.dialect === 'postgres') {\n    const parseResult: Partial<ConnectionOptions> = pgConnectionString.parse(connectionString);\n\n    delete parseResult.database;\n    delete parseResult.password;\n    delete parseResult.user;\n    delete parseResult.host;\n    delete parseResult.port;\n    delete parseResult.options; // we JSON.parse it\n\n    options.dialectOptions ||= Object.create(null) as DialectOptions;\n    Object.assign(options.dialectOptions, parseResult);\n  }\n\n  return options;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAiB;AACjB,sBAAoB;AAEpB,kCAA+B;AAE/B,kCAAmC;AACnC,0BAA2B;AAOpB,SAAS,sBAAsB,kBAAmC;AACvE,QAAM,UAAmB,CAAC;AAG1B,MAAI,qBAAqB,uBAAuB,qBAAqB,mBAAmB;AACtF,YAAQ,UAAU;AAClB,YAAQ,UAAU;AAElB,WAAO;AAAA,EACT;AAEA,QAAM,YAAY,IAAI,oBAAI,gBAAgB;AAE1C,MAAI,UAAU,UAAU;AACtB,QAAI,WAAW,UAAU,SAAS,QAAQ,MAAM,EAAE;AAClD,QAAI,aAAa,cAAc;AAC7B,iBAAW;AAAA,IACb;AAEA,QAAI,CAAC,+CAAmB,SAAS,QAAmB,GAAG;AACrD,YAAM,IAAI,MAAM,2BAA2B,KAAK,UAAU,QAAQ,yDAAyD,+CAAmB,IAAI,OAAK,KAAK,UAAU,CAAC,CAAC,EAAE,KAAK,IAAI,YAAY;AAAA,IACjM;AAEA,YAAQ,UAAU;AAAA,EACpB;AAEA,MAAI,UAAU,YAAY,MAAM;AAE9B,YAAQ,OAAO,mBAAmB,UAAU,QAAQ;AAAA,EACtD;AAEA,MAAI,UAAU,UAAU;AAEtB,YAAQ,WAAW,mBAAmB,UAAU,SAAS,QAAQ,OAAO,EAAE,CAAC;AAAA,EAC7E;AAEA,MAAI,UAAU,MAAM;AAClB,YAAQ,OAAO,UAAU;AAAA,EAC3B;AAEA,MAAI,UAAU,UAAU;AACtB,YAAQ,WAAW,mBAAmB,UAAU,QAAQ;AAAA,EAC1D;AAEA,MAAI,UAAU,UAAU;AACtB,YAAQ,WAAW,mBAAmB,UAAU,QAAQ;AAAA,EAC1D;AAEA,MAAI,UAAU,cAAc;AAK1B,QAAI,UAAU,aAAa,IAAI,MAAM,GAAG;AACtC,0CAAW;AACX,cAAQ,OAAO,mBAAmB,UAAU,aAAa,IAAI,MAAM,CAAE;AAAA,IACvE;AAEA,QAAI,QAAQ,YAAY,YAAY,UAAU,UAAU;AACtD,YAAM,cAAc,iBAAAA,QAAK,KAAK,QAAQ,MAAO,UAAU,QAAQ;AAC/D,aAAO,QAAQ;AACf,cAAQ,UAAU,iBAAAA,QAAK,QAAQ,QAAQ,WAAW,WAAW;AAAA,IAC/D;AAEA,YAAQ,iBAAiB,OAAO,YAAY,UAAU,aAAa,QAAQ,CAAC;AAC5E,QAAI,UAAU,aAAa,IAAI,SAAS,GAAG;AACzC,UAAI;AACF,cAAM,IAAI,KAAK,MAAM,UAAU,aAAa,IAAI,SAAS,CAAE;AAC3D,gBAAQ,eAAe,UAAU;AAAA,MACnC,QAAE;AAAA,MAGF;AAAA,IACF;AAAA,EACF;AAIA,MAAI,QAAQ,YAAY,YAAY;AAClC,UAAM,cAA0C,4BAAAC,QAAmB,MAAM,gBAAgB;AAEzF,WAAO,YAAY;AACnB,WAAO,YAAY;AACnB,WAAO,YAAY;AACnB,WAAO,YAAY;AACnB,WAAO,YAAY;AACnB,WAAO,YAAY;AAEnB,YAAQ,mBAAmB,uBAAO,OAAO,IAAI;AAC7C,WAAO,OAAO,QAAQ,gBAAgB,WAAW;AAAA,EACnD;AAEA,SAAO;AACT;",
  "names": ["path", "pgConnectionString"]
}
