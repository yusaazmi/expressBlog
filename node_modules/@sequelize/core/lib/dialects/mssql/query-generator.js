"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var query_generator_exports = {};
__export(query_generator_exports, {
  MsSqlQueryGenerator: () => MsSqlQueryGenerator
});
module.exports = __toCommonJS(query_generator_exports);
var import_check = require("../../utils/check");
var import_join_sql_fragments = require("../../utils/join-sql-fragments");
var import_query_builder_utils = require("../../utils/query-builder-utils");
var import_string = require("../../utils/string");
var import_data_types_utils = require("../abstract/data-types-utils");
var import_query_generator = require("../abstract/query-generator");
var import_each = __toESM(require("lodash/each"));
var import_forOwn = __toESM(require("lodash/forOwn"));
var import_isPlainObject = __toESM(require("lodash/isPlainObject"));
var import_isString = __toESM(require("lodash/isString"));
const DataTypes = require("../../data-types");
const { MsSqlQueryGeneratorTypeScript } = require("./query-generator-typescript");
const randomBytes = require("node:crypto").randomBytes;
const { Op } = require("../../operators");
function throwMethodUndefined(methodName) {
  throw new Error(`The method "${methodName}" is not defined! Please add it to your sql dialect.`);
}
const CREATE_TABLE_QUERY_SUPPORTED_OPTIONS = /* @__PURE__ */ new Set(["uniqueKeys"]);
const ADD_COLUMN_QUERY_SUPPORTED_OPTIONS = /* @__PURE__ */ new Set();
class MsSqlQueryGenerator extends MsSqlQueryGeneratorTypeScript {
  createTableQuery(tableName, attributes, options) {
    if (options) {
      (0, import_check.rejectInvalidOptions)(
        "createTableQuery",
        this.dialect.name,
        import_query_generator.CREATE_TABLE_QUERY_SUPPORTABLE_OPTIONS,
        CREATE_TABLE_QUERY_SUPPORTED_OPTIONS,
        options
      );
    }
    const primaryKeys = [];
    const foreignKeys = {};
    const attributesClauseParts = [];
    let commentStr = "";
    for (const attr in attributes) {
      if (Object.hasOwn(attributes, attr)) {
        let dataType = attributes[attr];
        let match;
        if (dataType.includes("COMMENT ")) {
          const commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);
          const commentText = commentMatch[2].replace("COMMENT", "").trim();
          commentStr += this.commentTemplate(commentText, tableName, attr);
          dataType = commentMatch[1];
        }
        if (dataType.includes("PRIMARY KEY")) {
          primaryKeys.push(attr);
          if (dataType.includes("REFERENCES")) {
            match = dataType.match(/^(.+) (REFERENCES.*)$/);
            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1].replace("PRIMARY KEY", "")}`);
            foreignKeys[attr] = match[2];
          } else {
            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType.replace("PRIMARY KEY", "")}`);
          }
        } else if (dataType.includes("REFERENCES")) {
          match = dataType.match(/^(.+) (REFERENCES.*)$/);
          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1]}`);
          foreignKeys[attr] = match[2];
        } else {
          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType}`);
        }
      }
    }
    const pkString = primaryKeys.map((pk) => this.quoteIdentifier(pk)).join(", ");
    if (options?.uniqueKeys) {
      (0, import_each.default)(options.uniqueKeys, (columns, indexName) => {
        if (typeof indexName !== "string") {
          indexName = (0, import_string.generateIndexName)(tableName, columns);
        }
        attributesClauseParts.push(`CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map((field) => this.quoteIdentifier(field)).join(", ")})`);
      });
    }
    if (pkString.length > 0) {
      attributesClauseParts.push(`PRIMARY KEY (${pkString})`);
    }
    for (const fkey in foreignKeys) {
      if (Object.hasOwn(foreignKeys, fkey)) {
        attributesClauseParts.push(`FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`);
      }
    }
    const quotedTableName = this.quoteTable(tableName);
    return (0, import_join_sql_fragments.joinSQLFragments)([
      `IF OBJECT_ID(${this.escape(quotedTableName)}, 'U') IS NULL`,
      `CREATE TABLE ${quotedTableName} (${attributesClauseParts.join(", ")})`,
      ";",
      commentStr
    ]);
  }
  addColumnQuery(table, key, dataType, options) {
    if (options) {
      (0, import_check.rejectInvalidOptions)(
        "addColumnQuery",
        this.dialect.name,
        import_query_generator.ADD_COLUMN_QUERY_SUPPORTABLE_OPTIONS,
        ADD_COLUMN_QUERY_SUPPORTED_OPTIONS,
        options
      );
    }
    dataType = {
      ...dataType,
      // TODO: attributeToSQL SHOULD be using attributes in addColumnQuery
      //       but instead we need to pass the key along as the field here
      field: key,
      type: (0, import_data_types_utils.normalizeDataType)(dataType.type, this.dialect)
    };
    let commentStr = "";
    if (dataType.comment && (0, import_isString.default)(dataType.comment)) {
      commentStr = this.commentTemplate(dataType.comment, table, key);
      delete dataType.comment;
    }
    return (0, import_join_sql_fragments.joinSQLFragments)([
      "ALTER TABLE",
      this.quoteTable(table),
      "ADD",
      this.quoteIdentifier(key),
      this.attributeToSQL(dataType, { context: "addColumn" }),
      ";",
      commentStr
    ]);
  }
  commentTemplate(comment, table, column) {
    const tableDetails = this.extractTableDetails(table);
    const tableName = tableDetails.tableName;
    const tableSchema = tableDetails.schema;
    return ` EXEC sp_addextendedproperty @name = N'MS_Description', @value = ${this.escape(comment)}, @level0type = N'Schema', @level0name = ${this.escape(tableSchema)}, @level1type = N'Table', @level1name = ${this.quoteIdentifier(tableName)}, @level2type = N'Column', @level2name = ${this.quoteIdentifier(column)};`;
  }
  changeColumnQuery(tableName, attributes) {
    const attrString = [];
    const constraintString = [];
    let commentString = "";
    for (const attributeName in attributes) {
      const quotedAttrName = this.quoteIdentifier(attributeName);
      let definition = attributes[attributeName];
      if (definition.includes("COMMENT ")) {
        const commentMatch = definition.match(/^(.+) (COMMENT.*)$/);
        const commentText = commentMatch[2].replace("COMMENT", "").trim();
        commentString += this.commentTemplate(commentText, tableName, attributeName);
        definition = commentMatch[1];
      }
      if (definition.includes("REFERENCES")) {
        constraintString.push(`FOREIGN KEY (${quotedAttrName}) ${definition.replace(/.+?(?=REFERENCES)/, "")}`);
      } else {
        attrString.push(`${quotedAttrName} ${definition}`);
      }
    }
    return (0, import_join_sql_fragments.joinSQLFragments)([
      "ALTER TABLE",
      this.quoteTable(tableName),
      attrString.length && `ALTER COLUMN ${attrString.join(", ")}`,
      constraintString.length && `ADD ${constraintString.join(", ")}`,
      ";",
      commentString
    ]);
  }
  renameColumnQuery(tableName, attrBefore, attributes) {
    const newName = Object.keys(attributes)[0];
    return (0, import_join_sql_fragments.joinSQLFragments)([
      "EXEC sp_rename",
      `'${this.quoteTable(tableName)}.${attrBefore}',`,
      `'${newName}',`,
      "'COLUMN'",
      ";"
    ]);
  }
  bulkInsertQuery(tableName, attrValueHashes, options, attributes) {
    const quotedTable = this.quoteTable(tableName);
    options = options || {};
    attributes = attributes || {};
    const tuples = [];
    const allAttributes = [];
    const allQueries = [];
    let needIdentityInsertWrapper = false;
    let outputFragment = "";
    if (options.returning) {
      const returnValues = this.generateReturnValues(attributes, options);
      outputFragment = returnValues.outputFragment;
    }
    const emptyQuery = `INSERT INTO ${quotedTable}${outputFragment} DEFAULT VALUES`;
    for (const attrValueHash of attrValueHashes) {
      const fields = Object.keys(attrValueHash);
      const firstAttr = attributes[fields[0]];
      if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {
        allQueries.push(emptyQuery);
        continue;
      }
      (0, import_forOwn.default)(attrValueHash, (value, key) => {
        if (value !== null && attributes[key] && attributes[key].autoIncrement) {
          needIdentityInsertWrapper = true;
        }
        if (!allAttributes.includes(key)) {
          if (value === null && attributes[key] && attributes[key].autoIncrement) {
            return;
          }
          allAttributes.push(key);
        }
      });
    }
    if (allAttributes.length > 0) {
      for (const attrValueHash of attrValueHashes) {
        tuples.push(`(${allAttributes.map((key) => {
          return this.escape(attrValueHash[key] ?? null, {
            type: attributes[key]?.type,
            replacements: options.replacements
          });
        }).join(",")})`);
      }
      const quotedAttributes = allAttributes.map((attr) => this.quoteIdentifier(attr)).join(",");
      allQueries.push((tupleStr) => `INSERT INTO ${quotedTable} (${quotedAttributes})${outputFragment} VALUES ${tupleStr}`);
    }
    const commands = [];
    let offset = 0;
    while (offset < Math.max(tuples.length, 1)) {
      const tupleStr = tuples.slice(offset, Math.min(tuples.length, offset + 1e3));
      let generatedQuery = allQueries.map((v) => typeof v === "string" ? v : v(tupleStr)).join(";");
      if (needIdentityInsertWrapper) {
        generatedQuery = `SET IDENTITY_INSERT ${quotedTable} ON; ${generatedQuery}; SET IDENTITY_INSERT ${quotedTable} OFF`;
      }
      commands.push(generatedQuery);
      offset += 1e3;
    }
    return `${commands.join(";")};`;
  }
  updateQuery(tableName, attrValueHash, where, options = {}, attributes) {
    const sql = super.updateQuery(tableName, attrValueHash, where, options, attributes);
    if (options.limit) {
      const updateArgs = `UPDATE TOP(${this.escape(options.limit, void 0, options)})`;
      sql.query = sql.query.replace("UPDATE", updateArgs);
    }
    return sql;
  }
  upsertQuery(tableName, insertValues, updateValues, where, model, options) {
    const targetTableAlias = this.quoteTable(`${tableName}_target`);
    const sourceTableAlias = this.quoteTable(`${tableName}_source`);
    const primaryKeysColumns = [];
    const identityColumns = [];
    const uniqueColumns = [];
    const tableNameQuoted = this.quoteTable(tableName);
    let needIdentityInsertWrapper = false;
    const modelDefinition = model.modelDefinition;
    for (const attribute of modelDefinition.attributes.values()) {
      if (attribute.primaryKey) {
        primaryKeysColumns.push(attribute.columnName);
      }
      if (attribute.autoIncrement) {
        identityColumns.push(attribute.columnName);
      }
    }
    for (const index of model.getIndexes()) {
      if (index.unique && index.fields) {
        for (const field of index.fields) {
          const columnName = typeof field === "string" ? field : field.name || field.attribute;
          if (!uniqueColumns.includes(columnName) && modelDefinition.attributes.has(columnName)) {
            uniqueColumns.push(columnName);
          }
        }
      }
    }
    const updateKeys = Object.keys(updateValues);
    const insertKeys = Object.keys(insertValues);
    const insertKeysQuoted = insertKeys.map((key) => this.quoteIdentifier(key)).join(", ");
    const insertValuesEscaped = insertKeys.map((key) => {
      return this.escape(insertValues[key], options);
    }).join(", ");
    const sourceTableQuery = `VALUES(${insertValuesEscaped})`;
    let joinCondition;
    for (const key of identityColumns) {
      if (insertValues[key] && insertValues[key] !== null) {
        needIdentityInsertWrapper = true;
      }
    }
    const clauses = where[Op.or].filter((clause) => {
      let valid = true;
      for (const key of Object.keys(clause)) {
        if (clause[key] == null) {
          valid = false;
          break;
        }
      }
      return valid;
    });
    const getJoinSnippet = (array) => {
      return array.map((key) => {
        key = this.quoteIdentifier(key);
        return `${targetTableAlias}.${key} = ${sourceTableAlias}.${key}`;
      });
    };
    if (clauses.length === 0) {
      throw new Error("Primary Key or Unique key should be passed to upsert query");
    } else {
      for (const key in clauses) {
        const keys = Object.keys(clauses[key]);
        const columnName = modelDefinition.getColumnNameLoose(keys[0]);
        if (primaryKeysColumns.includes(columnName)) {
          joinCondition = getJoinSnippet(primaryKeysColumns).join(" AND ");
          break;
        }
      }
      if (!joinCondition) {
        joinCondition = getJoinSnippet(uniqueColumns).join(" AND ");
      }
    }
    const filteredUpdateClauses = updateKeys.filter((key) => !identityColumns.includes(key)).map((key) => {
      const value = this.escape(updateValues[key], void 0, options);
      key = this.quoteIdentifier(key);
      return `${targetTableAlias}.${key} = ${value}`;
    });
    const updateSnippet = filteredUpdateClauses.length > 0 ? `WHEN MATCHED THEN UPDATE SET ${filteredUpdateClauses.join(", ")}` : "";
    const insertSnippet = `(${insertKeysQuoted}) VALUES(${insertValuesEscaped})`;
    let query = `MERGE INTO ${tableNameQuoted} WITH(HOLDLOCK) AS ${targetTableAlias} USING (${sourceTableQuery}) AS ${sourceTableAlias}(${insertKeysQuoted}) ON ${joinCondition}`;
    query += ` ${updateSnippet} WHEN NOT MATCHED THEN INSERT ${insertSnippet} OUTPUT $action, INSERTED.*;`;
    if (needIdentityInsertWrapper) {
      query = `SET IDENTITY_INSERT ${tableNameQuoted} ON; ${query} SET IDENTITY_INSERT ${tableNameQuoted} OFF;`;
    }
    return query;
  }
  attributeToSQL(attribute, options) {
    if (!(0, import_isPlainObject.default)(attribute)) {
      attribute = {
        type: attribute
      };
    }
    if (attribute.references && attribute.Model && this.isSameTable(attribute.Model.tableName, attribute.references.table)) {
      this.sequelize.log("MSSQL does not support self-referential constraints, we will remove it but we recommend restructuring your query");
      attribute.onDelete = "";
      attribute.onUpdate = "";
    }
    let template;
    if (attribute.type instanceof DataTypes.ENUM) {
      template = attribute.type.toSql({ dialect: this.dialect });
      template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.type.options.values.map((value) => {
        return this.escape(value, options);
      }).join(", ")}))`;
      return template;
    }
    template = (0, import_data_types_utils.attributeTypeToSql)(attribute.type, { dialect: this.dialect });
    if (attribute.allowNull === false) {
      template += " NOT NULL";
    } else if (!attribute.primaryKey && !(0, import_query_builder_utils.defaultValueSchemable)(attribute.defaultValue, this.dialect)) {
      template += " NULL";
    }
    if (attribute.autoIncrement) {
      template += " IDENTITY(1,1)";
    }
    if (attribute.type !== "TEXT" && attribute.type._binary !== true && (0, import_query_builder_utils.defaultValueSchemable)(attribute.defaultValue, this.dialect)) {
      template += ` DEFAULT ${this.escape(attribute.defaultValue, { ...options, type: attribute.type })}`;
    }
    if (attribute.unique === true && (options?.context !== "changeColumn" || this.dialect.supports.alterColumn.unique)) {
      template += " UNIQUE";
    }
    if (attribute.primaryKey) {
      template += " PRIMARY KEY";
    }
    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {
      template += ` REFERENCES ${this.quoteTable(attribute.references.table)}`;
      if (attribute.references.key) {
        template += ` (${this.quoteIdentifier(attribute.references.key)})`;
      } else {
        template += ` (${this.quoteIdentifier("id")})`;
      }
      if (attribute.onDelete) {
        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;
      }
      if (attribute.onUpdate) {
        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;
      }
    }
    if (attribute.comment && typeof attribute.comment === "string") {
      template += ` COMMENT ${attribute.comment}`;
    }
    return template;
  }
  attributesToSQL(attributes, options) {
    const result = /* @__PURE__ */ Object.create(null);
    const existingConstraints = [];
    for (const key of Object.keys(attributes)) {
      const attribute = { ...attributes[key] };
      if (attribute.references) {
        if (existingConstraints.includes(this.quoteTable(attribute.references.table))) {
          attribute.onDelete = "";
          attribute.onUpdate = "";
        } else {
          existingConstraints.push(this.quoteTable(attribute.references.table));
          attribute.onUpdate = "";
        }
      }
      if (key && !attribute.field) {
        attribute.field = key;
      }
      result[attribute.field || key] = this.attributeToSQL(attribute, options);
    }
    return result;
  }
  createTrigger() {
    throwMethodUndefined("createTrigger");
  }
  dropTrigger() {
    throwMethodUndefined("dropTrigger");
  }
  renameTrigger() {
    throwMethodUndefined("renameTrigger");
  }
  createFunction() {
    throwMethodUndefined("createFunction");
  }
  dropFunction() {
    throwMethodUndefined("dropFunction");
  }
  renameFunction() {
    throwMethodUndefined("renameFunction");
  }
  setIsolationLevelQuery() {
  }
  generateTransactionId() {
    return randomBytes(10).toString("hex");
  }
  startTransactionQuery(transaction) {
    if (transaction.parent) {
      return `SAVE TRANSACTION ${this.quoteIdentifier(transaction.name)};`;
    }
    return "BEGIN TRANSACTION;";
  }
  commitTransactionQuery(transaction) {
    if (transaction.parent) {
      return;
    }
    return "COMMIT TRANSACTION;";
  }
  rollbackTransactionQuery(transaction) {
    if (transaction.parent) {
      return `ROLLBACK TRANSACTION ${this.quoteIdentifier(transaction.name)};`;
    }
    return "ROLLBACK TRANSACTION;";
  }
}
//# sourceMappingURL=query-generator.js.map
