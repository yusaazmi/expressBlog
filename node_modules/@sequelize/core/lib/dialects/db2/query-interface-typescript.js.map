{
  "version": 3,
  "sources": ["../../../src/dialects/db2/query-interface-typescript.ts"],
  "sourcesContent": ["import { QueryTypes } from '../../query-types';\nimport { AbstractQueryInterface } from '../abstract/query-interface';\nimport type { QiDropAllSchemasOptions } from '../abstract/query-interface.types';\nimport type { Db2Dialect } from './index.js';\n\nexport class Db2QueryInterfaceTypeScript<Dialect extends Db2Dialect = Db2Dialect> extends AbstractQueryInterface<Dialect> {\n  async dropAllSchemas(options?: QiDropAllSchemasOptions): Promise<void> {\n    const skip = options?.skip || [];\n    const allSchemas = await this.listSchemas(options);\n    const schemaNames = allSchemas.filter(schemaName => !skip.includes(schemaName));\n\n    // if the dialect does not support \"cascade\", then drop all tables and routines first in a loop to avoid deadlocks and timeouts\n    if (options?.cascade === undefined) {\n      for (const schema of schemaNames) {\n        // eslint-disable-next-line no-await-in-loop\n        await this.dropAllTables({ ...options, schema });\n\n        // In Db2 the routines are scoped to the schema, so we need to drop them separately for each schema\n        // eslint-disable-next-line no-await-in-loop\n        const routines = await this.sequelize.queryRaw<{ ROUTINENAME: string, ROUTINETYPE: 'F' | 'M' | 'P' }>(`SELECT ROUTINENAME, ROUTINETYPE FROM SYSCAT.ROUTINES WHERE ROUTINESCHEMA = ${this.queryGenerator.escape(schema)}`, {\n          ...options,\n          type: QueryTypes.SELECT,\n        });\n        for (const routine of routines) {\n          const type = routine.ROUTINETYPE === 'F'\n          ? 'FUNCTION'\n          : routine.ROUTINETYPE === 'P'\n          ? 'PROCEDURE'\n          : routine.ROUTINETYPE === 'M'\n          ? 'METHOD'\n          : '';\n          // eslint-disable-next-line no-await-in-loop\n          await this.sequelize.queryRaw(`DROP ${type} ${this.quoteIdentifier(schema)}.${this.quoteIdentifier(routine.ROUTINENAME)}`, options);\n        }\n\n        // In Db2 the triggers are scoped to the schema, so we need to drop them separately for each schema\n        // eslint-disable-next-line no-await-in-loop\n        const triggers = await this.sequelize.queryRaw<{ TRIGNAME: string }>(`SELECT TRIGNAME FROM SYSCAT.TRIGGERS WHERE TRIGSCHEMA = ${this.queryGenerator.escape(schema)}`, {\n          ...options,\n          type: QueryTypes.SELECT,\n        });\n        for (const trigger of triggers) {\n          // eslint-disable-next-line no-await-in-loop\n          await this.sequelize.queryRaw(`DROP TRIGGER ${this.quoteIdentifier(schema)}.${this.quoteIdentifier(trigger.TRIGNAME)}`, options);\n        }\n      }\n    }\n\n    // Drop all the schemas in a loop to avoid deadlocks and timeouts\n    for (const schema of schemaNames) {\n      // eslint-disable-next-line no-await-in-loop\n      await this.dropSchema(schema, options);\n    }\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBAA2B;AAC3B,6BAAuC;AAIhC,MAAM,oCAA6E,8CAAgC;AAAA,EACxH,MAAM,eAAe,SAAkD;AACrE,UAAM,OAAO,SAAS,QAAQ,CAAC;AAC/B,UAAM,aAAa,MAAM,KAAK,YAAY,OAAO;AACjD,UAAM,cAAc,WAAW,OAAO,gBAAc,CAAC,KAAK,SAAS,UAAU,CAAC;AAG9E,QAAI,SAAS,YAAY,QAAW;AAClC,iBAAW,UAAU,aAAa;AAEhC,cAAM,KAAK,cAAc,EAAE,GAAG,SAAS,OAAO,CAAC;AAI/C,cAAM,WAAW,MAAM,KAAK,UAAU,SAAgE,8EAA8E,KAAK,eAAe,OAAO,MAAM,KAAK;AAAA,UACxN,GAAG;AAAA,UACH,MAAM,8BAAW;AAAA,QACnB,CAAC;AACD,mBAAW,WAAW,UAAU;AAC9B,gBAAM,OAAO,QAAQ,gBAAgB,MACnC,aACA,QAAQ,gBAAgB,MACxB,cACA,QAAQ,gBAAgB,MACxB,WACA;AAEF,gBAAM,KAAK,UAAU,SAAS,QAAQ,QAAQ,KAAK,gBAAgB,MAAM,KAAK,KAAK,gBAAgB,QAAQ,WAAW,KAAK,OAAO;AAAA,QACpI;AAIA,cAAM,WAAW,MAAM,KAAK,UAAU,SAA+B,2DAA2D,KAAK,eAAe,OAAO,MAAM,KAAK;AAAA,UACpK,GAAG;AAAA,UACH,MAAM,8BAAW;AAAA,QACnB,CAAC;AACD,mBAAW,WAAW,UAAU;AAE9B,gBAAM,KAAK,UAAU,SAAS,gBAAgB,KAAK,gBAAgB,MAAM,KAAK,KAAK,gBAAgB,QAAQ,QAAQ,KAAK,OAAO;AAAA,QACjI;AAAA,MACF;AAAA,IACF;AAGA,eAAW,UAAU,aAAa;AAEhC,YAAM,KAAK,WAAW,QAAQ,OAAO;AAAA,IACvC;AAAA,EACF;AACF;",
  "names": []
}
