"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var query_generator_typescript_exports = {};
__export(query_generator_typescript_exports, {
  Db2QueryGeneratorTypeScript: () => Db2QueryGeneratorTypeScript
});
module.exports = __toCommonJS(query_generator_typescript_exports);
var import_operators = require("../../operators.js");
var import_check = require("../../utils/check");
var import_join_sql_fragments = require("../../utils/join-sql-fragments");
var import_string = require("../../utils/string");
var import_query_generator = require("../abstract/query-generator");
var import_query_generator_typescript = require("../abstract/query-generator-typescript");
var import_query_generator_internal = require("./query-generator-internal.js");
const DROP_SCHEMA_QUERY_SUPPORTED_OPTIONS = /* @__PURE__ */ new Set();
const REMOVE_INDEX_QUERY_SUPPORTED_OPTIONS = /* @__PURE__ */ new Set();
const RENAME_TABLE_QUERY_SUPPORTED_OPTIONS = /* @__PURE__ */ new Set();
const TRUNCATE_TABLE_QUERY_SUPPORTED_OPTIONS = /* @__PURE__ */ new Set();
class Db2QueryGeneratorTypeScript extends import_query_generator.AbstractQueryGenerator {
  #internals;
  constructor(dialect, internals = new import_query_generator_internal.Db2QueryGeneratorInternal(dialect)) {
    super(dialect, internals);
    internals.whereSqlBuilder.setOperatorKeyword(import_operators.Op.regexp, "REGEXP_LIKE");
    internals.whereSqlBuilder.setOperatorKeyword(import_operators.Op.notRegexp, "NOT REGEXP_LIKE");
    this.#internals = internals;
  }
  dropSchemaQuery(schemaName, options) {
    if (options) {
      (0, import_check.rejectInvalidOptions)(
        "dropSchemaQuery",
        this.dialect.name,
        import_query_generator_typescript.DROP_SCHEMA_QUERY_SUPPORTABLE_OPTIONS,
        DROP_SCHEMA_QUERY_SUPPORTED_OPTIONS,
        options
      );
    }
    return `DROP SCHEMA ${this.quoteIdentifier(schemaName)} RESTRICT`;
  }
  listSchemasQuery(options) {
    let schemasToSkip = this.#internals.getTechnicalSchemaNames();
    if (options && Array.isArray(options?.skip)) {
      schemasToSkip = [...schemasToSkip, ...options.skip];
    }
    return (0, import_join_sql_fragments.joinSQLFragments)([
      'SELECT SCHEMANAME AS "schema" FROM SYSCAT.SCHEMATA',
      `WHERE SCHEMANAME NOT LIKE 'SYS%' AND SCHEMANAME NOT IN (${schemasToSkip.map((schema) => this.escape(schema)).join(", ")})`
    ]);
  }
  describeTableQuery(tableName) {
    const table = this.extractTableDetails(tableName);
    return (0, import_join_sql_fragments.joinSQLFragments)([
      'SELECT COLNAME AS "Name",',
      'TABNAME AS "Table",',
      'TABSCHEMA AS "Schema",',
      'TYPENAME AS "Type",',
      'LENGTH AS "Length",',
      'SCALE AS "Scale",',
      'NULLS AS "IsNull",',
      'DEFAULT AS "Default",',
      'COLNO AS "Colno",',
      'IDENTITY AS "IsIdentity",',
      'KEYSEQ AS "KeySeq",',
      'REMARKS AS "Comment"',
      "FROM SYSCAT.COLUMNS",
      `WHERE TABNAME = ${this.escape(table.tableName)}`,
      `AND TABSCHEMA = ${this.escape(table.schema)}`
    ]);
  }
  listTablesQuery(options) {
    return (0, import_join_sql_fragments.joinSQLFragments)([
      'SELECT TABNAME AS "tableName",',
      'TRIM(TABSCHEMA) AS "schema"',
      `FROM SYSCAT.TABLES WHERE TYPE = 'T'`,
      options?.schema ? `AND TABSCHEMA = ${this.escape(options.schema)}` : `AND TABSCHEMA NOT LIKE 'SYS%' AND TABSCHEMA NOT IN (${this.#internals.getTechnicalSchemaNames().map((schema) => this.escape(schema)).join(", ")})`,
      "ORDER BY TABSCHEMA, TABNAME"
    ]);
  }
  renameTableQuery(beforeTableName, afterTableName, options) {
    if (options) {
      (0, import_check.rejectInvalidOptions)(
        "renameTableQuery",
        this.dialect.name,
        import_query_generator_typescript.RENAME_TABLE_QUERY_SUPPORTABLE_OPTIONS,
        RENAME_TABLE_QUERY_SUPPORTED_OPTIONS,
        options
      );
    }
    const beforeTable = this.extractTableDetails(beforeTableName);
    const afterTable = this.extractTableDetails(afterTableName);
    if (beforeTable.schema !== afterTable.schema) {
      throw new Error(`Moving tables between schemas is not supported by ${this.dialect.name} dialect.`);
    }
    return `RENAME TABLE ${this.quoteTable(beforeTableName)} TO ${this.quoteIdentifier(afterTable.tableName)}`;
  }
  truncateTableQuery(tableName, options) {
    if (options) {
      (0, import_check.rejectInvalidOptions)(
        "truncateTableQuery",
        this.dialect.name,
        import_query_generator_typescript.TRUNCATE_TABLE_QUERY_SUPPORTABLE_OPTIONS,
        TRUNCATE_TABLE_QUERY_SUPPORTED_OPTIONS,
        options
      );
    }
    return `TRUNCATE TABLE ${this.quoteTable(tableName)} IMMEDIATE`;
  }
  #getConstraintType(type) {
    switch (type) {
      case "CHECK":
        return "K";
      case "FOREIGN KEY":
        return "F";
      case "PRIMARY KEY":
        return "P";
      case "UNIQUE":
        return "U";
      default:
        throw new Error(`Constraint type ${type} is not supported`);
    }
  }
  showConstraintsQuery(tableName, options) {
    const table = this.extractTableDetails(tableName);
    return (0, import_join_sql_fragments.joinSQLFragments)([
      'SELECT TRIM(c.TABSCHEMA) AS "constraintSchema",',
      'c.CONSTNAME AS "constraintName",',
      `CASE c.TYPE WHEN 'P' THEN 'PRIMARY KEY' WHEN 'F' THEN 'FOREIGN KEY' WHEN 'K' THEN 'CHECK' WHEN 'U' THEN 'UNIQUE' ELSE NULL END AS "constraintType",`,
      'TRIM(c.TABSCHEMA) AS "tableSchema",',
      'c.TABNAME AS "tableName",',
      'k.COLNAME AS "columnNames",',
      'TRIM(r.REFTABSCHEMA) AS "referencedTableSchema",',
      'r.REFTABNAME AS "referencedTableName",',
      'fk.COLNAME AS "referencedColumnNames",',
      `CASE r.DELETERULE WHEN 'A' THEN 'NO ACTION' WHEN 'C' THEN 'CASCADE' WHEN 'N' THEN 'SET NULL' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "deleteAction",`,
      `CASE r.UPDATERULE WHEN 'A' THEN 'NO ACTION' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "updateAction",`,
      'ck.TEXT AS "definition"',
      "FROM SYSCAT.TABCONST c",
      "LEFT JOIN SYSCAT.REFERENCES r ON c.CONSTNAME = r.CONSTNAME AND c.TABNAME = r.TABNAME AND c.TABSCHEMA = r.TABSCHEMA",
      "LEFT JOIN SYSCAT.KEYCOLUSE k ON c.CONSTNAME = k.CONSTNAME AND c.TABNAME = k.TABNAME AND c.TABSCHEMA = k.TABSCHEMA",
      "LEFT JOIN SYSCAT.KEYCOLUSE fk ON r.REFKEYNAME = fk.CONSTNAME",
      "LEFT JOIN SYSCAT.CHECKS ck ON c.CONSTNAME = ck.CONSTNAME AND c.TABNAME = ck.TABNAME AND c.TABSCHEMA = ck.TABSCHEMA",
      `WHERE c.TABNAME = ${this.escape(table.tableName)}`,
      `AND c.TABSCHEMA = ${this.escape(table.schema)}`,
      options?.columnName ? `AND k.COLNAME = ${this.escape(options.columnName)}` : "",
      options?.constraintName ? `AND c.CONSTNAME = ${this.escape(options.constraintName)}` : "",
      options?.constraintType ? `AND c.TYPE = ${this.escape(this.#getConstraintType(options.constraintType))}` : "",
      "ORDER BY c.CONSTNAME, k.COLSEQ, fk.COLSEQ"
    ]);
  }
  showIndexesQuery(tableName) {
    const table = this.extractTableDetails(tableName);
    return (0, import_join_sql_fragments.joinSQLFragments)([
      "SELECT",
      'i.INDNAME AS "name",',
      'i.TABNAME AS "tableName",',
      'i.UNIQUERULE AS "keyType",',
      'i.INDEXTYPE AS "type",',
      'c.COLNAME AS "columnName",',
      'c.COLORDER AS "columnOrder"',
      "FROM SYSCAT.INDEXES i",
      "INNER JOIN SYSCAT.INDEXCOLUSE c ON i.INDNAME = c.INDNAME AND i.INDSCHEMA = c.INDSCHEMA",
      `WHERE TABNAME = ${this.escape(table.tableName)}`,
      `AND TABSCHEMA = ${this.escape(table.schema)}`,
      "ORDER BY i.INDNAME, c.COLSEQ;"
    ]);
  }
  removeIndexQuery(tableName, indexNameOrAttributes, options) {
    if (options) {
      (0, import_check.rejectInvalidOptions)(
        "removeIndexQuery",
        this.dialect.name,
        import_query_generator_typescript.REMOVE_INDEX_QUERY_SUPPORTABLE_OPTIONS,
        REMOVE_INDEX_QUERY_SUPPORTED_OPTIONS,
        options
      );
    }
    let indexName;
    if (Array.isArray(indexNameOrAttributes)) {
      const table = this.extractTableDetails(tableName);
      indexName = (0, import_string.generateIndexName)(table, { fields: indexNameOrAttributes });
    } else {
      indexName = indexNameOrAttributes;
    }
    return `DROP INDEX ${this.quoteIdentifier(indexName)}`;
  }
  versionQuery() {
    return 'select service_level as "version" from TABLE (sysproc.env_get_inst_info()) as A';
  }
  tableExistsQuery(tableName) {
    const table = this.extractTableDetails(tableName);
    return `SELECT TABNAME FROM SYSCAT.TABLES WHERE TABNAME = ${this.escape(table.tableName)} AND TABSCHEMA = ${this.escape(table.schema)}`;
  }
}
//# sourceMappingURL=query-generator-typescript.js.map
