"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var query_interface_exports = {};
__export(query_interface_exports, {
  SqliteQueryInterface: () => SqliteQueryInterface
});
module.exports = __toCommonJS(query_interface_exports);
var import_isEmpty = __toESM(require("lodash/isEmpty"));
var import_errors = require("../../errors");
var import_query_types = require("../../query-types");
var import_deprecations = require("../../utils/deprecations");
var import_query_interface = require("../abstract/query-interface");
var import_query_interface_internal = require("./query-interface-internal");
var import_sqlite_utils = require("./sqlite-utils");
class SqliteQueryInterface extends import_query_interface.AbstractQueryInterface {
  #internalQueryInterface;
  constructor(dialect, internalQueryInterface) {
    internalQueryInterface ??= new import_query_interface_internal.SqliteQueryInterfaceInternal(dialect);
    super(dialect, internalQueryInterface);
    this.#internalQueryInterface = internalQueryInterface;
  }
  async dropAllTables(options) {
    const skip = options?.skip || [];
    const allTables = await this.listTables(options);
    const tableNames = allTables.filter((tableName) => !skip.includes(tableName.tableName));
    await (0, import_sqlite_utils.withSqliteForeignKeysOff)(this.sequelize, options, async () => {
      for (const table of tableNames) {
        await this.dropTable(table, options);
      }
    });
  }
  async describeTable(tableName, options) {
    const table = this.queryGenerator.extractTableDetails(tableName);
    if (typeof options === "string") {
      (0, import_deprecations.noSchemaParameter)();
      table.schema = options;
    }
    if (typeof options === "object" && options !== null) {
      if (options.schema) {
        (0, import_deprecations.noSchemaParameter)();
        table.schema = options.schema;
      }
      if (options.schemaDelimiter) {
        (0, import_deprecations.noSchemaDelimiterParameter)();
        table.delimiter = options.schemaDelimiter;
      }
    }
    const sql = this.queryGenerator.describeTableQuery(table);
    try {
      const data = await this.sequelize.queryRaw(sql, { ...options, type: import_query_types.QueryTypes.DESCRIBE });
      if ((0, import_isEmpty.default)(data)) {
        throw new Error(`No description found for table ${table.tableName}${table.schema ? ` in schema ${table.schema}` : ""}. Check the table name and schema; remember, they _are_ case sensitive.`);
      }
      for (const column of Object.values(data)) {
        column.unique = false;
      }
      const indexes = await this.showIndex(tableName, options);
      for (const index of indexes) {
        for (const field of index.fields) {
          if (index.unique !== void 0) {
            data[field.attribute].unique = index.unique;
          }
        }
      }
      const foreignKeys = await this.showConstraints(tableName, { ...options, constraintType: "FOREIGN KEY" });
      for (const foreignKey of foreignKeys) {
        for (const [index, columnName] of foreignKey.columnNames.entries()) {
          Object.assign(data[columnName], {
            references: {
              table: foreignKey.referencedTableName,
              key: foreignKey.referencedColumnNames.at(index)
            },
            onUpdate: foreignKey.updateAction,
            onDelete: foreignKey.deleteAction
          });
        }
      }
      return data;
    } catch (error) {
      if (error instanceof import_errors.BaseError && error.cause?.code === "ER_NO_SUCH_TABLE") {
        throw new Error(`No description found for table ${table.tableName}${table.schema ? ` in schema ${table.schema}` : ""}. Check the table name and schema; remember, they _are_ case sensitive.`);
      }
      throw error;
    }
  }
  async addConstraint(tableName, options) {
    if (!options.fields) {
      throw new Error("Fields must be specified through options.fields");
    }
    if (!options.type) {
      throw new Error("Constraint type must be specified through options.type");
    }
    const constraintSnippet = this.queryGenerator._TEMPORARY_getConstraintSnippet(tableName, options);
    const describeCreateTableSql = this.queryGenerator.describeCreateTableQuery(tableName);
    const describeCreateTable = await this.sequelize.queryRaw(describeCreateTableSql, {
      ...options,
      raw: true,
      type: import_query_types.QueryTypes.SELECT
    });
    if (!describeCreateTable.length || !("sql" in describeCreateTable[0])) {
      throw new Error("Unable to find constraints for table. Perhaps the table does not exist?");
    }
    let { sql: createTableSql } = describeCreateTable[0];
    createTableSql = createTableSql.replaceAll('"', "`").replace(/\);?$/, `, ${constraintSnippet})`);
    const fields = await this.describeTable(tableName, options);
    const sql = this.queryGenerator._replaceTableQuery(tableName, fields, createTableSql);
    await this.#internalQueryInterface.executeQueriesSequentially(sql, { ...options, raw: true });
  }
  async removeConstraint(tableName, constraintName, options) {
    const describeCreateTableSql = this.queryGenerator.describeCreateTableQuery(tableName);
    const describeCreateTable = await this.sequelize.queryRaw(describeCreateTableSql, {
      ...options,
      raw: true,
      type: import_query_types.QueryTypes.SELECT
    });
    if (!describeCreateTable.length || !("sql" in describeCreateTable[0])) {
      throw new Error("Unable to find constraints for table. Perhaps the table does not exist?");
    }
    const { sql: createTableSql } = describeCreateTable[0];
    const constraints = await this.showConstraints(tableName, options);
    const constraint = constraints.find((c) => c.constraintName === constraintName);
    if (!constraint) {
      const table = this.queryGenerator.extractTableDetails(tableName);
      throw new import_errors.UnknownConstraintError({
        message: `Constraint ${constraintName} on table ${table.tableName} does not exist`,
        constraint: constraintName,
        table: table.tableName
      });
    }
    constraint.constraintName = this.queryGenerator.quoteIdentifier(constraint.constraintName);
    let constraintSnippet = `, CONSTRAINT ${constraint.constraintName} ${constraint.constraintType} ${constraint.definition}`;
    if (constraint.constraintType === "FOREIGN KEY") {
      constraintSnippet = `, CONSTRAINT ${constraint.constraintName} FOREIGN KEY`;
      const columns = constraint.columnNames.map((columnName) => this.queryGenerator.quoteIdentifier(columnName)).join(", ");
      const referenceTableName = this.queryGenerator.quoteTable(constraint.referencedTableName);
      const referenceTableColumns = constraint.referencedColumnNames.map((columnName) => this.queryGenerator.quoteIdentifier(columnName)).join(", ");
      constraintSnippet += ` (${columns})`;
      constraintSnippet += ` REFERENCES ${referenceTableName} (${referenceTableColumns})`;
      constraintSnippet += constraint.updateAction ? ` ON UPDATE ${constraint.updateAction}` : "";
      constraintSnippet += constraint.deleteAction ? ` ON DELETE ${constraint.deleteAction}` : "";
    } else if (["PRIMARY KEY", "UNIQUE"].includes(constraint.constraintType)) {
      constraintSnippet = `, CONSTRAINT ${constraint.constraintName} ${constraint.constraintType}`;
      const columns = constraint.columnNames.map((columnName) => this.queryGenerator.quoteIdentifier(columnName)).join(", ");
      constraintSnippet += ` (${columns})`;
    }
    const fields = await this.describeTable(tableName, options);
    const sql = this.queryGenerator._replaceTableQuery(tableName, fields, createTableSql.replaceAll('"', "`").replace(constraintSnippet, ""));
    await this.#internalQueryInterface.executeQueriesSequentially(sql, { ...options, raw: true });
  }
  async showConstraints(tableName, options) {
    const describeCreateTableSql = this.queryGenerator.describeCreateTableQuery(tableName);
    const describeCreateTable = await this.sequelize.queryRaw(describeCreateTableSql, {
      ...options,
      raw: true,
      type: import_query_types.QueryTypes.SELECT
    });
    if (!describeCreateTable.length || !("sql" in describeCreateTable[0])) {
      throw new Error("Unable to find constraints for table. Perhaps the table does not exist?");
    }
    const { sql: createTableSql } = describeCreateTable[0];
    const match = /CREATE TABLE (?:`|'|")(\S+)(?:`|'|") \((.+)\)/.exec(createTableSql);
    const data = [];
    if (match) {
      const [, constraintTableName, attributeSQL] = match;
      const keys = [];
      const attributes = [];
      const constraints = [];
      const sqlAttributes = attributeSQL.split(/,(?![^(]*\))/).map((attr) => attr.trim());
      for (const attribute of sqlAttributes) {
        if (attribute.startsWith("CONSTRAINT")) {
          constraints.push(attribute);
        } else if (attribute.startsWith("PRIMARY KEY") || attribute.startsWith("FOREIGN KEY")) {
          keys.push(attribute);
        } else {
          attributes.push(attribute);
        }
      }
      for (const attribute of attributes) {
        const [, column, type] = attribute.match(/`(\S+)` (.+)/) || [];
        if (/\bPRIMARY KEY\b/.test(type)) {
          data.push({
            constraintSchema: "",
            constraintName: "PRIMARY",
            constraintType: "PRIMARY KEY",
            tableSchema: "",
            tableName: constraintTableName,
            columnNames: [column]
          });
        } else if (/\bREFERENCES\b/.test(type)) {
          const deleteAction = type.match(/ON DELETE (\w+(?: (?!ON UPDATE)\w+)?)/);
          const updateAction = type.match(/ON UPDATE (\w+(?: (?!ON DELETE)\w+)?)/);
          const [, referencedTableName, referencedColumnNames] = type.match(/REFERENCES `(\S+)` \(`(\S+)`\)/) || [];
          data.push({
            constraintSchema: "",
            constraintName: "FOREIGN",
            constraintType: "FOREIGN KEY",
            tableSchema: "",
            tableName: constraintTableName,
            columnNames: [column],
            referencedTableSchema: "",
            referencedTableName: referencedTableName ?? "",
            referencedColumnNames: [referencedColumnNames],
            deleteAction: deleteAction?.at(1) ?? "",
            updateAction: updateAction?.at(1) ?? ""
          });
        } else if (/\bUNIQUE\b/.test(type)) {
          data.push({
            constraintSchema: "",
            constraintName: "UNIQUE",
            constraintType: "UNIQUE",
            tableSchema: "",
            tableName: constraintTableName,
            columnNames: [column]
          });
        } else if (/\bCHECK\b/.test(type)) {
          const definition = type.match(/CHECK (.+)/);
          data.push({
            constraintSchema: "",
            constraintName: "CHECK",
            constraintType: "CHECK",
            tableSchema: "",
            tableName: constraintTableName,
            columnNames: [column],
            definition: definition ? definition[1] ?? "" : ""
          });
        }
      }
      for (const constraint of constraints) {
        const [, constraintName, constraintType, definition] = constraint.match(/CONSTRAINT (?:`|'|")(\S+)(?:`|'|") (\w+(?: \w+)?) (.+)/) || [];
        if (/\bPRIMARY KEY\b/.test(constraint)) {
          const columnsMatch = [...definition.matchAll(/`(\S+)`/g)];
          data.push({
            constraintSchema: "",
            constraintName,
            constraintType: "PRIMARY KEY",
            tableSchema: "",
            tableName: constraintTableName,
            columnNames: columnsMatch.map((col) => col[1])
          });
        } else if (/\bREFERENCES\b/.test(constraint)) {
          const deleteAction = definition.match(/ON DELETE (\w+(?: (?!ON UPDATE)\w+)?)/);
          const updateAction = definition.match(/ON UPDATE (\w+(?: (?!ON DELETE)\w+)?)/);
          const [, rawColumnNames, referencedTableName, rawReferencedColumnNames] = definition.match(/\(([^\s,]+(?:,\s?[^\s,]+)*)\) REFERENCES `(\S+)` \(([^\s,]+(?:,\s?[^\s,]+)*)\)/) || [];
          const columnsMatch = [...rawColumnNames.matchAll(/`(\S+)`/g)];
          const referencedColumnNames = [...rawReferencedColumnNames.matchAll(/`(\S+)`/g)];
          data.push({
            constraintSchema: "",
            constraintName,
            constraintType: "FOREIGN KEY",
            tableSchema: "",
            tableName: constraintTableName,
            columnNames: columnsMatch.map((col) => col[1]),
            referencedTableSchema: "",
            referencedTableName: referencedTableName ?? "",
            referencedColumnNames: referencedColumnNames.map((col) => col[1]),
            deleteAction: deleteAction?.at(1) ?? "",
            updateAction: updateAction?.at(1) ?? ""
          });
        } else if (["CHECK", "DEFAULT", "UNIQUE"].includes(constraintType)) {
          const columnsMatch = [...definition.matchAll(/`(\S+)`/g)];
          data.push({
            constraintSchema: "",
            constraintName,
            constraintType,
            tableSchema: "",
            tableName: constraintTableName,
            ...constraintType !== "CHECK" && { columnNames: columnsMatch.map((col) => col[1]) },
            ...constraintType !== "UNIQUE" && { definition }
          });
        }
      }
      for (const key of keys) {
        const [, constraintType, rawColumnNames] = key.match(/(\w+(?: \w+)?)\s?\(([^\s,]+(?:,\s?[^\s,]+)*)\)/) || [];
        const columnsMatch = [...rawColumnNames.matchAll(/`(\S+)`/g)];
        const columnNames = columnsMatch.map((col) => col[1]);
        if (constraintType === "PRIMARY KEY") {
          data.push({
            constraintSchema: "",
            constraintName: "PRIMARY",
            constraintType,
            tableSchema: "",
            tableName: constraintTableName,
            columnNames
          });
        } else if (constraintType === "FOREIGN KEY") {
          const deleteAction = key.match(/ON DELETE (\w+(?: (?!ON UPDATE)\w+)?)/);
          const updateAction = key.match(/ON UPDATE (\w+(?: (?!ON DELETE)\w+)?)/);
          const [, referencedTableName, rawReferencedColumnNames] = key.match(/REFERENCES `(\S+)` \(([^\s,]+(?:,\s?[^\s,]+)*)\)/) || [];
          const referencedColumnNames = [...rawReferencedColumnNames.matchAll(/`(\S+)`/g)];
          data.push({
            constraintSchema: "",
            constraintName: "FOREIGN",
            constraintType,
            tableSchema: "",
            tableName: constraintTableName,
            columnNames,
            referencedTableSchema: "",
            referencedTableName,
            referencedColumnNames: referencedColumnNames.map((col) => col[1]),
            deleteAction: deleteAction?.at(1) ?? "",
            updateAction: updateAction?.at(1) ?? ""
          });
        }
      }
    } else {
      throw new Error(`Could not parse constraints from SQL: ${createTableSql}`);
    }
    let constraintData = data;
    if (options?.columnName) {
      constraintData = constraintData.filter((constraint) => constraint.columnNames?.includes(options.columnName));
      constraintData = constraintData.map((constraint) => {
        if (constraint.columnNames) {
          constraint.columnNames = constraint.columnNames.filter((column) => column === options.columnName);
        }
        return constraint;
      });
    }
    if (options?.constraintName) {
      constraintData = constraintData.filter((constraint) => constraint.constraintName === options.constraintName);
    }
    if (options?.constraintType) {
      constraintData = constraintData.filter((constraint) => constraint.constraintType === options.constraintType);
    }
    return constraintData;
  }
  /**
   * A wrapper that fixes SQLite's inability to remove columns from existing tables.
   * It will create a backup of the table, drop the table afterwards and create a
   * new table with the same name but without the obsolete column.
   *
   * @param tableName
   * @param removeColumn
   * @param options
   */
  async removeColumn(tableName, removeColumn, options) {
    const fields = await this.describeTable(tableName, options);
    delete fields[removeColumn];
    await this.#internalQueryInterface.alterTableInternal(tableName, fields, options);
  }
  /**
   * A wrapper that fixes SQLite's inability to change columns from existing tables.
   * It will create a backup of the table, drop the table afterwards and create a
   * new table with the same name but with a modified version of the respective column.
   *
   * @param tableName
   * @param columnName
   * @param dataTypeOrOptions
   * @param options
   */
  async changeColumn(tableName, columnName, dataTypeOrOptions, options) {
    const columns = await this.describeTable(tableName, options);
    for (const column of Object.values(columns)) {
      delete column.unique;
    }
    Object.assign(columns[columnName], this.sequelize.normalizeAttribute(dataTypeOrOptions));
    await this.#internalQueryInterface.alterTableInternal(tableName, columns, options);
  }
  /**
   * A wrapper that fixes SQLite's inability to rename columns from existing tables.
   * It will create a backup of the table, drop the table afterwards and create a
   * new table with the same name but with a renamed version of the respective column.
   *
   * @param tableName
   * @param attrNameBefore
   * @param attrNameAfter
   * @param options
   */
  async renameColumn(tableName, attrNameBefore, attrNameAfter, options) {
    const fields = await this.assertTableHasColumn(tableName, attrNameBefore, options);
    fields[attrNameAfter] = { ...fields[attrNameBefore] };
    delete fields[attrNameBefore];
    const sql = this.queryGenerator._replaceColumnQuery(tableName, attrNameBefore, attrNameAfter, fields);
    await this.#internalQueryInterface.executeQueriesSequentially(sql, { ...options, raw: true });
  }
}
//# sourceMappingURL=query-interface.js.map
