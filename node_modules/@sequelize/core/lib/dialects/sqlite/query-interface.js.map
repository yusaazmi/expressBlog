{
  "version": 3,
  "sources": ["../../../src/dialects/sqlite/query-interface.ts"],
  "sourcesContent": ["import isEmpty from 'lodash/isEmpty';\nimport { BaseError, UnknownConstraintError } from '../../errors';\nimport type { AttributeOptions } from '../../model';\nimport { QueryTypes } from '../../query-types';\nimport type { QueryRawOptions } from '../../sequelize';\nimport { noSchemaDelimiterParameter, noSchemaParameter } from '../../utils/deprecations';\nimport type { DataType } from '../abstract/data-types';\nimport type { TableNameOrModel } from '../abstract/query-generator-typescript';\nimport { AbstractQueryInterface } from '../abstract/query-interface';\nimport type {\n  AddConstraintOptions,\n  ConstraintDescription,\n  ConstraintType,\n  DescribeTableOptions,\n  QiDropAllTablesOptions,\n  RemoveColumnOptions,\n  RemoveConstraintOptions,\n  ShowConstraintsOptions,\n} from '../abstract/query-interface.types';\nimport { SqliteQueryInterfaceInternal } from './query-interface-internal';\nimport type { SqliteColumnsDescription } from './query-interface.types';\nimport { withSqliteForeignKeysOff } from './sqlite-utils';\nimport type { SqliteDialect } from './index.js';\n\nexport class SqliteQueryInterface<Dialect extends SqliteDialect = SqliteDialect> extends AbstractQueryInterface<Dialect> {\n  readonly #internalQueryInterface: SqliteQueryInterfaceInternal;\n\n  constructor(\n    dialect: Dialect,\n    internalQueryInterface?: SqliteQueryInterfaceInternal,\n  ) {\n    internalQueryInterface ??= new SqliteQueryInterfaceInternal(dialect);\n\n    super(dialect, internalQueryInterface);\n    this.#internalQueryInterface = internalQueryInterface;\n  }\n\n  async dropAllTables(options?: QiDropAllTablesOptions): Promise<void> {\n    const skip = options?.skip || [];\n    const allTables = await this.listTables(options);\n    const tableNames = allTables.filter(tableName => !skip.includes(tableName.tableName));\n\n    await withSqliteForeignKeysOff(this.sequelize, options, async () => {\n      for (const table of tableNames) {\n        // eslint-disable-next-line no-await-in-loop\n        await this.dropTable(table, options);\n      }\n    });\n  }\n\n  async describeTable(tableName: TableNameOrModel, options?: DescribeTableOptions): Promise<SqliteColumnsDescription> {\n    const table = this.queryGenerator.extractTableDetails(tableName);\n\n    if (typeof options === 'string') {\n      noSchemaParameter();\n      table.schema = options;\n    }\n\n    if (typeof options === 'object' && options !== null) {\n      if (options.schema) {\n        noSchemaParameter();\n        table.schema = options.schema;\n      }\n\n      if (options.schemaDelimiter) {\n        noSchemaDelimiterParameter();\n        table.delimiter = options.schemaDelimiter;\n      }\n    }\n\n    const sql = this.queryGenerator.describeTableQuery(table);\n    try {\n      const data = await this.sequelize.queryRaw(sql, { ...options, type: QueryTypes.DESCRIBE }) as SqliteColumnsDescription;\n      /*\n       * If no data is returned from the query, then the table name may be wrong.\n       * Query generators that use information_schema for retrieving table info will just return an empty result set,\n       * it will not throw an error like built-ins do (e.g. DESCRIBE on MySql).\n       */\n      if (isEmpty(data)) {\n        throw new Error(`No description found for table ${table.tableName}${table.schema ? ` in schema ${table.schema}` : ''}. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n\n      // This is handled by copying indexes over,\n      // we don't use \"unique\" because it creates an index with a name\n      // we can't control\n      for (const column of Object.values(data)) {\n        column.unique = false;\n      }\n\n      const indexes = await this.showIndex(tableName, options);\n      for (const index of indexes) {\n        for (const field of index.fields) {\n          if (index.unique !== undefined) {\n            data[field.attribute].unique = index.unique;\n          }\n        }\n      }\n\n      // Sqlite requires the foreign keys added to the column definitions\n      // when describing a table as this is required in the replaceTableQuery\n      const foreignKeys = await this.showConstraints(tableName, { ...options, constraintType: 'FOREIGN KEY' });\n      for (const foreignKey of foreignKeys) {\n        for (const [index, columnName] of foreignKey.columnNames!.entries()) {\n          // Add constraints to column definition\n          Object.assign(data[columnName], {\n            references: {\n              table: foreignKey.referencedTableName,\n              key: foreignKey.referencedColumnNames!.at(index),\n            },\n            onUpdate: foreignKey.updateAction,\n            onDelete: foreignKey.deleteAction,\n          });\n        }\n      }\n\n      return data;\n    } catch (error) {\n      if (error instanceof BaseError && error.cause?.code === 'ER_NO_SUCH_TABLE') {\n        throw new Error(`No description found for table ${table.tableName}${table.schema ? ` in schema ${table.schema}` : ''}. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n\n      throw error;\n    }\n  }\n\n  async addConstraint(tableName: TableNameOrModel, options: AddConstraintOptions): Promise<void> {\n    if (!options.fields) {\n      throw new Error('Fields must be specified through options.fields');\n    }\n\n    if (!options.type) {\n      throw new Error('Constraint type must be specified through options.type');\n    }\n\n    const constraintSnippet = this.queryGenerator._TEMPORARY_getConstraintSnippet(tableName, options);\n    const describeCreateTableSql = this.queryGenerator.describeCreateTableQuery(tableName);\n    const describeCreateTable = await this.sequelize.queryRaw(describeCreateTableSql, {\n      ...options,\n      raw: true,\n      type: QueryTypes.SELECT,\n    });\n\n    if (!describeCreateTable.length || !('sql' in describeCreateTable[0])) {\n      throw new Error('Unable to find constraints for table. Perhaps the table does not exist?');\n    }\n\n    let { sql: createTableSql } = describeCreateTable[0] as { sql: string };\n    // Replace double quotes with backticks and ending ')' with constraint snippet\n    createTableSql = createTableSql.replaceAll('\"', '`').replace(/\\);?$/, `, ${constraintSnippet})`);\n\n    const fields = await this.describeTable(tableName, options);\n    const sql = this.queryGenerator._replaceTableQuery(tableName, fields, createTableSql);\n    await this.#internalQueryInterface.executeQueriesSequentially(sql, { ...options, raw: true });\n  }\n\n  async removeConstraint(\n    tableName: TableNameOrModel,\n    constraintName: string,\n    options?: RemoveConstraintOptions,\n  ): Promise<void> {\n    const describeCreateTableSql = this.queryGenerator.describeCreateTableQuery(tableName);\n    const describeCreateTable = await this.sequelize.queryRaw(describeCreateTableSql, {\n      ...options,\n      raw: true,\n      type: QueryTypes.SELECT,\n    });\n\n    if (!describeCreateTable.length || !('sql' in describeCreateTable[0])) {\n      throw new Error('Unable to find constraints for table. Perhaps the table does not exist?');\n    }\n\n    const { sql: createTableSql } = describeCreateTable[0] as { sql: string };\n    const constraints = await this.showConstraints(tableName, options);\n    const constraint = constraints.find(c => c.constraintName === constraintName);\n\n    if (!constraint) {\n      const table = this.queryGenerator.extractTableDetails(tableName);\n      throw new UnknownConstraintError({\n        message: `Constraint ${constraintName} on table ${table.tableName} does not exist`,\n        constraint: constraintName,\n        table: table.tableName,\n      });\n    }\n\n    constraint.constraintName = this.queryGenerator.quoteIdentifier(constraint.constraintName);\n    let constraintSnippet = `, CONSTRAINT ${constraint.constraintName} ${constraint.constraintType} ${constraint.definition}`;\n\n    if (constraint.constraintType === 'FOREIGN KEY') {\n      constraintSnippet = `, CONSTRAINT ${constraint.constraintName} FOREIGN KEY`;\n      const columns = constraint.columnNames!.map(columnName => this.queryGenerator.quoteIdentifier(columnName)).join(', ');\n      const referenceTableName = this.queryGenerator.quoteTable(constraint.referencedTableName!);\n      const referenceTableColumns = constraint.referencedColumnNames!.map(columnName => this.queryGenerator.quoteIdentifier(columnName)).join(', ');\n      constraintSnippet += ` (${columns})`;\n      constraintSnippet += ` REFERENCES ${referenceTableName} (${referenceTableColumns})`;\n      constraintSnippet += constraint.updateAction ? ` ON UPDATE ${constraint.updateAction}` : '';\n      constraintSnippet += constraint.deleteAction ? ` ON DELETE ${constraint.deleteAction}` : '';\n    } else if (['PRIMARY KEY', 'UNIQUE'].includes(constraint.constraintType)) {\n      constraintSnippet = `, CONSTRAINT ${constraint.constraintName} ${constraint.constraintType}`;\n      const columns = constraint.columnNames!.map(columnName => this.queryGenerator.quoteIdentifier(columnName)).join(', ');\n      constraintSnippet += ` (${columns})`;\n    }\n\n    const fields = await this.describeTable(tableName, options);\n    // Replace double quotes with backticks and remove constraint snippet\n    const sql = this.queryGenerator._replaceTableQuery(tableName, fields, createTableSql.replaceAll('\"', '`').replace(constraintSnippet, ''));\n    await this.#internalQueryInterface.executeQueriesSequentially(sql, { ...options, raw: true });\n  }\n\n  async showConstraints(tableName: TableNameOrModel, options?: ShowConstraintsOptions): Promise<ConstraintDescription[]> {\n    const describeCreateTableSql = this.queryGenerator.describeCreateTableQuery(tableName);\n    const describeCreateTable = await this.sequelize.queryRaw(describeCreateTableSql, {\n      ...options,\n      raw: true,\n      type: QueryTypes.SELECT,\n    });\n\n    if (!describeCreateTable.length || !('sql' in describeCreateTable[0])) {\n      throw new Error('Unable to find constraints for table. Perhaps the table does not exist?');\n    }\n\n    const { sql: createTableSql } = describeCreateTable[0] as { sql: string };\n    const match = /CREATE TABLE (?:`|'|\")(\\S+)(?:`|'|\") \\((.+)\\)/.exec(createTableSql);\n    const data: ConstraintDescription[] = [];\n\n    if (match) {\n      const [, constraintTableName, attributeSQL] = match;\n      const keys = [];\n      const attributes = [];\n      const constraints = [];\n      const sqlAttributes = attributeSQL.split(/,(?![^(]*\\))/).map(attr => attr.trim());\n      for (const attribute of sqlAttributes) {\n        if (attribute.startsWith('CONSTRAINT')) {\n          constraints.push(attribute);\n        } else if (attribute.startsWith('PRIMARY KEY') || attribute.startsWith('FOREIGN KEY')) {\n          keys.push(attribute);\n        } else {\n          attributes.push(attribute);\n        }\n      }\n\n      for (const attribute of attributes) {\n        const [, column, type] = attribute.match(/`(\\S+)` (.+)/) || [];\n        if (/\\bPRIMARY KEY\\b/.test(type)) {\n          data.push({\n            constraintSchema: '',\n            constraintName: 'PRIMARY',\n            constraintType: 'PRIMARY KEY',\n            tableSchema: '',\n            tableName: constraintTableName,\n            columnNames: [column],\n          });\n        } else if (/\\bREFERENCES\\b/.test(type)) {\n          const deleteAction = type.match(/ON DELETE (\\w+(?: (?!ON UPDATE)\\w+)?)/);\n          const updateAction = type.match(/ON UPDATE (\\w+(?: (?!ON DELETE)\\w+)?)/);\n          const [, referencedTableName, referencedColumnNames] = type.match(/REFERENCES `(\\S+)` \\(`(\\S+)`\\)/) || [];\n\n          data.push({\n            constraintSchema: '',\n            constraintName: 'FOREIGN',\n            constraintType: 'FOREIGN KEY',\n            tableSchema: '',\n            tableName: constraintTableName,\n            columnNames: [column],\n            referencedTableSchema: '',\n            referencedTableName: referencedTableName ?? '',\n            referencedColumnNames: [referencedColumnNames],\n            deleteAction: deleteAction?.at(1) ?? '',\n            updateAction: updateAction?.at(1) ?? '',\n          });\n        } else if (/\\bUNIQUE\\b/.test(type)) {\n          data.push({\n            constraintSchema: '',\n            constraintName: 'UNIQUE',\n            constraintType: 'UNIQUE',\n            tableSchema: '',\n            tableName: constraintTableName,\n            columnNames: [column],\n          });\n        } else if (/\\bCHECK\\b/.test(type)) {\n          const definition = type.match(/CHECK (.+)/);\n\n          data.push({\n            constraintSchema: '',\n            constraintName: 'CHECK',\n            constraintType: 'CHECK',\n            tableSchema: '',\n            tableName: constraintTableName,\n            columnNames: [column],\n            definition: definition ? definition[1] ?? '' : '',\n          });\n        }\n      }\n\n      for (const constraint of constraints) {\n        const [, constraintName, constraintType, definition] = constraint.match(/CONSTRAINT (?:`|'|\")(\\S+)(?:`|'|\") (\\w+(?: \\w+)?) (.+)/) || [];\n        if (/\\bPRIMARY KEY\\b/.test(constraint)) {\n          const columnsMatch = [...definition.matchAll(/`(\\S+)`/g)];\n\n          data.push({\n            constraintSchema: '',\n            constraintName,\n            constraintType: 'PRIMARY KEY',\n            tableSchema: '',\n            tableName: constraintTableName,\n            columnNames: columnsMatch.map(col => col[1]),\n          });\n        } else if (/\\bREFERENCES\\b/.test(constraint)) {\n          const deleteAction = definition.match(/ON DELETE (\\w+(?: (?!ON UPDATE)\\w+)?)/);\n          const updateAction = definition.match(/ON UPDATE (\\w+(?: (?!ON DELETE)\\w+)?)/);\n          const [, rawColumnNames, referencedTableName, rawReferencedColumnNames] = definition.match(/\\(([^\\s,]+(?:,\\s?[^\\s,]+)*)\\) REFERENCES `(\\S+)` \\(([^\\s,]+(?:,\\s?[^\\s,]+)*)\\)/) || [];\n          const columnsMatch = [...rawColumnNames.matchAll(/`(\\S+)`/g)];\n          const referencedColumnNames = [...rawReferencedColumnNames.matchAll(/`(\\S+)`/g)];\n\n          data.push({\n            constraintSchema: '',\n            constraintName,\n            constraintType: 'FOREIGN KEY',\n            tableSchema: '',\n            tableName: constraintTableName,\n            columnNames: columnsMatch.map(col => col[1]),\n            referencedTableSchema: '',\n            referencedTableName: referencedTableName ?? '',\n            referencedColumnNames: referencedColumnNames.map(col => col[1]),\n            deleteAction: deleteAction?.at(1) ?? '',\n            updateAction: updateAction?.at(1) ?? '',\n          });\n        } else if (['CHECK', 'DEFAULT', 'UNIQUE'].includes(constraintType)) {\n          const columnsMatch = [...definition.matchAll(/`(\\S+)`/g)];\n\n          data.push({\n            constraintSchema: '',\n            constraintName,\n            constraintType: constraintType as ConstraintType,\n            tableSchema: '',\n            tableName: constraintTableName,\n            ...constraintType !== 'CHECK' && { columnNames: columnsMatch.map(col => col[1]) },\n            ...constraintType !== 'UNIQUE' && { definition },\n          });\n        }\n      }\n\n      for (const key of keys) {\n        const [, constraintType, rawColumnNames] = key.match(/(\\w+(?: \\w+)?)\\s?\\(([^\\s,]+(?:,\\s?[^\\s,]+)*)\\)/) || [];\n        const columnsMatch = [...rawColumnNames.matchAll(/`(\\S+)`/g)];\n        const columnNames = columnsMatch.map(col => col[1]);\n\n        if (constraintType === 'PRIMARY KEY') {\n          data.push({\n            constraintSchema: '',\n            constraintName: 'PRIMARY',\n            constraintType,\n            tableSchema: '',\n            tableName: constraintTableName,\n            columnNames,\n          });\n        } else if (constraintType === 'FOREIGN KEY') {\n          const deleteAction = key.match(/ON DELETE (\\w+(?: (?!ON UPDATE)\\w+)?)/);\n          const updateAction = key.match(/ON UPDATE (\\w+(?: (?!ON DELETE)\\w+)?)/);\n          const [, referencedTableName, rawReferencedColumnNames] = key.match(/REFERENCES `(\\S+)` \\(([^\\s,]+(?:,\\s?[^\\s,]+)*)\\)/) || [];\n          const referencedColumnNames = [...rawReferencedColumnNames.matchAll(/`(\\S+)`/g)];\n\n          data.push({\n            constraintSchema: '',\n            constraintName: 'FOREIGN',\n            constraintType,\n            tableSchema: '',\n            tableName: constraintTableName,\n            columnNames,\n            referencedTableSchema: '',\n            referencedTableName,\n            referencedColumnNames: referencedColumnNames.map(col => col[1]),\n            deleteAction: deleteAction?.at(1) ?? '',\n            updateAction: updateAction?.at(1) ?? '',\n          });\n        }\n      }\n    } else {\n      throw new Error(`Could not parse constraints from SQL: ${createTableSql}`);\n    }\n\n    let constraintData = data;\n\n    if (options?.columnName) {\n      constraintData = constraintData.filter(constraint => constraint.columnNames?.includes(options.columnName!));\n      constraintData = constraintData.map(constraint => {\n        if (constraint.columnNames) {\n          constraint.columnNames = constraint.columnNames.filter(column => column === options.columnName);\n        }\n\n        return constraint;\n      });\n    }\n\n    if (options?.constraintName) {\n      constraintData = constraintData.filter(constraint => constraint.constraintName === options.constraintName);\n    }\n\n    if (options?.constraintType) {\n      constraintData = constraintData.filter(constraint => constraint.constraintType === options.constraintType);\n    }\n\n    return constraintData;\n  }\n\n  /**\n   * A wrapper that fixes SQLite's inability to remove columns from existing tables.\n   * It will create a backup of the table, drop the table afterwards and create a\n   * new table with the same name but without the obsolete column.\n   *\n   * @param tableName\n   * @param removeColumn\n   * @param options\n   */\n  async removeColumn(\n    tableName: TableNameOrModel,\n    removeColumn: string,\n    options?: RemoveColumnOptions,\n  ): Promise<void> {\n    const fields = await this.describeTable(tableName, options);\n    delete fields[removeColumn];\n\n    await this.#internalQueryInterface.alterTableInternal(tableName, fields, options);\n  }\n\n  /**\n   * A wrapper that fixes SQLite's inability to change columns from existing tables.\n   * It will create a backup of the table, drop the table afterwards and create a\n   * new table with the same name but with a modified version of the respective column.\n   *\n   * @param tableName\n   * @param columnName\n   * @param dataTypeOrOptions\n   * @param options\n   */\n  async changeColumn(\n    tableName: TableNameOrModel,\n    columnName: string,\n    dataTypeOrOptions: DataType | AttributeOptions,\n    options?: QueryRawOptions,\n  ): Promise<void> {\n    const columns = await this.describeTable(tableName, options);\n    for (const column of Object.values(columns)) {\n      // This is handled by copying indexes over,\n      // we don't use \"unique\" because it creates an index with a name\n      // we can't control\n      delete column.unique;\n    }\n\n    Object.assign(columns[columnName], this.sequelize.normalizeAttribute(dataTypeOrOptions));\n\n    await this.#internalQueryInterface.alterTableInternal(tableName, columns, options);\n  }\n\n  /**\n   * A wrapper that fixes SQLite's inability to rename columns from existing tables.\n   * It will create a backup of the table, drop the table afterwards and create a\n   * new table with the same name but with a renamed version of the respective column.\n   *\n   * @param tableName\n   * @param attrNameBefore\n   * @param attrNameAfter\n   * @param options\n   */\n  async renameColumn(\n    tableName: TableNameOrModel,\n    attrNameBefore: string,\n    attrNameAfter: string,\n    options?: QueryRawOptions,\n  ): Promise<void> {\n    const fields = await this.assertTableHasColumn(tableName, attrNameBefore, options);\n\n    fields[attrNameAfter] = { ...fields[attrNameBefore] };\n    delete fields[attrNameBefore];\n\n    const sql = this.queryGenerator._replaceColumnQuery(tableName, attrNameBefore, attrNameAfter, fields);\n    await this.#internalQueryInterface.executeQueriesSequentially(sql, { ...options, raw: true });\n  }\n}\n"],
  "mappings": "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",
  "names": ["isEmpty"]
}
